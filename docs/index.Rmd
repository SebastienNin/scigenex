---
title: "The scigenex library"
author: "J. Bavais, Sebastien Nin, Aurelie Bergon, Fabrice Lopez, L. Spinelli and D. Puthier"
date: "`r Sys.Date()`"
abstract: >
  The scigenex package (Single-Cell Informative GENe Explorer) proposes a set of functions to *(i)* extract informative genes from a scRNA-seq experiment, *(ii)* search, store and annotate clusters of co-expressed genes and *(iii)* map them onto UMAP or t-SNE diagram to functionally annotate cell populations. Although users may use their own method to extract informative genes and define gene cluster, we propose, by default, an implementation of the DBFMCL algorithm (*Density Based Filtering and Markov CLustering*) that was previously developed for microarray analysis and have been adapted here for scRNA-seq dataset. The robustness of this algorithm makes it particularly well suited for automated analysis of a scRNA-seq data to get a first intuition of the regulated genes and their impact on cell heterogeneity.
  scigenex package version: `r packageVersion("scigenex")`
output:
  html_document:
    fig_caption: yes
    highlight: zenburn
    theme: cerulean
    toc: yes
    toc_depth: 3
    toc_float: yes
  pdf_document:
    fig_caption: yes
    highlight: zenburn
    toc: no
    toc_depth: 3
  word_document: default
bibliography: library.bib
vignette: >
  %\VignetteIndexEntry{Analyzing scRNA-seq data with DBFMCL}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\usepackage[utf8]{inputenc}
---




<style>

p.comment {
background-color: #D6EBF0;
color: #24535E;
padding: 10px;
border: 1px solid #C6E4EA;
margin-left: 25px;
border-radius: 5px;
font-style: italic;
}

p.alert {
background-color: #F3D8DA;
color: #692225;
padding: 10px;
border: 1px solid #EEC8CB;
margin-left: 25px;
border-radius: 5px;
font-style: italic;
}
</style>

```{r setup, echo=FALSE, results="hide"}
knitr::opts_chunk$set(tidy = FALSE,
                      cache = FALSE,
                      dev = "png",
                      message = FALSE, error = FALSE, warning = TRUE)
```


NOTE: THIS VERSION IS CURRENTLY UNSTABLE AND ONLY FOR DEVELOPMENT PURPOSE.


**Note:** if you use scigenex in published research, please cite:

https://github.com/dputhier/scigenex


# Installation


## Installing DBFMCL


```{r installation, installation, eval=TRUE, echo=TRUE, include=TRUE}
devtools::install_github("dputhier/scigenex")
library(scigenex)
```

## Installing MCL {#installation}

<p class="alert">
**Warning:** The scigenex library implements the DBFMCL algorithm. Although an implementation of MCL exists for R (see the [MCL library](https://cran.r-project.org/web/packages/MCL/index.html)) we very strongly encourage you to install [the original MCL tool](http://micans.org/) from S.M. van Dongen. Indeed, the R version is slower, not reproducible and produced very different results from the original version. 
</p>

You may install MCL using conda. Importantly, the *mcl* command should be in your PATH and reachable from within R.

```{bash condainstall, eval=FALSE}
conda install -c bioconda mcl
```

Alternatively install MCL from sources.

```{bash mclfromsource, eval=FALSE}
# Download the latest version of mcl 
wget http://micans.org/mcl/src/mcl-latest.tar.gz
# Uncompress and install mcl
tar xvfz mcl-latest.tar.gz
cd mcl-xx-xxx
./configure
make
sudo make install
# You should get mcl in your path
mcl -h
```



```{r, eval=FALSE, echo=FALSE, include=FALSE}
# This is for developement purpose
# please adapt the path.
path_to_scigenex_git = "/Users/puthier/Documents/git/project_dev/scigenex/"

reinstall <- function(){
  # For development purpose
  # please adapt the path
  try(detach("package:scigenex"), silent = TRUE)
  library(devtools)
  roxygen2::roxygenise(path_to_scigenex_git)
  install(path_to_scigenex_git)
}
reinstall()
```

# Loading and normalizing the PBMC dataset

For this tutorial, we will use the classical Seurat dataset related to Peripheral Blood Mononuclear Cells (PBMC) that is freely available from 10X Genomics. This [dataset](https://cf.10xgenomics.com/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz) contains 2,700 single cells sequenced on the Illumina NextSeq 500. 
  

```{r loadingseurat}
library(Seurat)
library(ggplot2)

# Load the PBMC dataset
# please adapt the path
setwd("~/Downloads/")
pbmc_data <- Read10X(data.dir = "filtered_gene_bc_matrices/hg19/")
pbmc_raw <- CreateSeuratObject(counts = pbmc_data, project = "pbmc3k",
                               min.cells = 3, 
                               min.features = 200)

```

We compute the classical QC metrics and  define a set of cells for further analysis.

```{r}
# Filter cells based on QC metrics
pbmc_raw[["percent.mt"]] <- PercentageFeatureSet(pbmc_raw, pattern = "^MT-")
pbmc_raw <- subset(pbmc_raw, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)
```

Then the dataset is normalized as in the classical approach described in Seurat package.


```{r normalizingseurat}

# Perform simple log-transformation and scaling
pbmc_norm <- NormalizeData(pbmc_raw, 
                          normalization.method = "LogNormalize",
                          scale.factor = 10000)



```


# Selecting Features and getting gene cluster

One of the pivotal object of the scigenex package is the *ClusterSet object*. This object can be created from a count matrix and  list of user defined sets of informative gene (TODO: implement ClusterSetFromGeneSets). 

TODO: provide an example of user defined gene/cluster selection (e.g. variance + K-means).

The scigenex package also proposes another solution that uses the *DBFMCL()* algorithm. This algorithm which was previously develop for microarray data analysis has been adapted for scRNA-seq analysis. The objective of the algorithm is dual: (i) select informative genes, (ii) define a set of gene cluster with the same expression profile.

<p class="comment">
**Note about DBFMCL.** One important issue in high throuput gene expression analysis is the selection of informative features (i.e genes) and the identification of gene clusters. These datasets are considered to be highly noisy and a typical way of selecting features is to filter them based on variance. Regarding gene partitioning a popular solution is to use k-means. In the context of the microarray data analysis we had shown that another way of selecting informative genes is to try to capture groups of highly correlated features (clusters). These genes can be viewed as elements displaying weak distances to their nearest neighbors that represent densely populated regions  (i.e. strong profile similarities). This solution was previously implemented in the DBFMCL (Density-Based Filtering and Markov Clustering) algorithm. To isolate these regions DBF-MCL computes, for each gene/element, the distance with its kth nearest neighbor (DKNN). In order to define a critical DKNN value (that will depend on the dataset), DBF-MCL computes simulated DKNN values by using an empirical randomization procedure. Given a dataset containing n genes and p samples, a simulated DKNN value is obtained by sampling n distance values from the gene-gene distance matrix D and by extracting the kth-smallest value. This procedure is repeated n times to obtain a set of simulated DKNN values S. Computed distributions of simulated DKNN are used to
compute a FDR value for each observed DKNN value. The critical value of DKNN is the one for which a user-defined FDR value (typically 10%) is observed. Genes with DKNN value below this threshold are selected and used to construct a graph. In this graph, edges are constructed between two genes (nodes) if one of them belongs to the k-nearest neighbors of the other. Edges are weighted based on the respective coefficient of correlation (i.e., similarity) and the graph obtained is partitioned using the Markov CLustering algorithm (MCL).
While this algorithm was previously developed for microarray we have adapted it to work with discrete data, especially scRNA-seq data.
</p>


From this Seurat object we can directly perform feature selection and gene cluster inference with DBFMCL. Here *DBFMCL()* is used with default arguments. Note that the *mcl_cmd_line* is set to true to indicate that we won't use the R implementation of MCL (see \@ref(installation))


```{r rundbf}
library(scigenex)
pbmc_df <- as.data.frame(pbmc_norm@assays$RNA@data)

# NOTE: Under Rstudio, the progress bar may sometimes freeze
# while the algorithm is still running. This has to
# be fixed.
dbf <- DBFMCL(pbmc_df, 
              mcl_cmd_line=TRUE,
              distance_method="pearson",
              av_dot_prod_min=2,
              k = 50,
              inflation = 8)
nrow(dbf)
```

# The clusterSet object

The result of the DBFMCL function is an S4 object (ClusterSet).

```{r}
is(dbf)
```
This object contains the following slots:

```{r}
slotNames(dbf)
```

It has the following methods:

```{r}
showMethods(class="ClusterSet", where = "package:scigenex")
```

Here the number of selected informative genes is:

```{r}
nrow(dbf)
```


# Search of cell populations using DBFMCL selected genes

The gene filtered using DBFMCL can now be used to subset a Seurat Object and search for cell populations.

```{r}
pbmc_dbf <- pbmc_norm
VariableFeatures(pbmc_dbf) <- rownames(dbf@data)
pbmc_dbf <- ScaleData(pbmc_dbf)
pbmc_dbf <- RunPCA(pbmc_dbf, features = rownames(pbmc_dbf))
pbmc_dbf <- RunUMAP(pbmc_dbf, dims = 1:10)
pbmc_dbf <- FindNeighbors(pbmc_dbf, reduction = "pca", dims = 1:20)
pbmc_dbf <- FindClusters(pbmc_dbf)
dim_plot_dbf <- DimPlot(pbmc_dbf, reduction = "umap")
dim_plot_dbf
```

# Transfer infered cell populations to a ClusterSet object

The inferred populations can now be transferred into the ClusterSet object using the *load_seurat()* method and represented using the plot_clust function.

```{r}
dbf_seurat <- load_seurat(dbf, 
                          seurat_obj=pbmc_dbf,
                          dimplot_obj=dim_plot_dbf)

```

# Visualizing gene clusters

The *plot_clust()* method can be used to display the cluster of co-regulated genes. Here we only display the average expression profile of each cluster. Note that to improve readability data are floored and ceiled (si corresponding arguments).
 
```{r plot_clust}
g_profiles <- plot_clust(dbf_seurat,
                       average_only = TRUE,
                       floor=-1, 
                       ceil=1)
g_profiles
```

Both the dimplot and gene profiles can be presented in the same diagram using the command below

```{r}
g_profiles_no_legend <- g_profiles + theme(legend.position = "none")
g_profiles_no_legend + dim_plot_dbf
```

Alternatively the cluster obtained can be represented using a heatmap (thanks to the *type* argument that can be set to 'tile'):

```{r plot_clust_heatmap}
g_heatmap <- plot_clust(dbf_seurat, 
                         average_only = TRUE,
                         type="tile",
                         floor=-1, 
                         ceil=1)
g_heatmap
```

# Assessing the expression level of clusters in cell populations

Checking the level of expression of each cluster in the cell population can be checked using the AddModuleScore from the Seurat library which calculates 'the average expression levels of each program (cluster) on single cell level, subtracted by the aggregated expression of control feature sets'.

```{r FeaturePlot_by_clust}
for(i in 1:max(dbf_seurat@cluster)){
  tmp_features <- list(rownames(dbf_seurat@data)[dbf_seurat@cluster == i ])
pbmc_dbf <- AddModuleScore(object = pbmc_dbf, 
                           features = tmp_features, 
                           name = paste("cluster_", i, "_", sep=""), ctrl = 5)
}

module_list <- vector()
for(i in 1:max(dbf_seurat@cluster)){
  module_list[i] <- paste("cluster_", i, "_1", sep="")
}

FeaturePlot(object = pbmc_dbf, 
            features = module_list)
```
Cluster 1 to 4 and 9 clearly highlight some coordinated gene regulations that occur specifically in particular cell populations. In constrast gene clusters 5 to 8 seem to have very close average profile (see heatmap above). However, closests inspection shows they have expression restricted to different cell populations. Indeed, the cluster 8 contains several genes related to cell cycle highlight that some some cells are apparently in active division or at least engaged in a cell division process. Regarding, gene cluster 5, 6 and 7 it is hard to tell whether they would have to be merged into a single one. However, the FeaturePlot show below tend to indicate that they could represent some diversity inside a single cell population (platelets as shown later).  

```{r FeaturePlot_clust_5_to_7}
plist <- FeaturePlot(pbmc_dbf, 
                     features=c("cluster_5_1", "cluster_6_1", "cluster_7_1"))
plist & xlim(c(-8.7, -8.1)) & ylim(c(4.4, 5.1))
```

# Comparing DBFMCL gene filtering with variance stabilizing transformation

We can compare the clustering power of the gene selected using DBFMCL with those obtained using the original method from Seurat (variance stabilizing transformation, vst). As shown below, on this PBMC dataset, DBFMCL selected genes (left) tend to produce a more resolutive map of cell populations.

```{r}
# Create a dimplot using original (vst) gene filtering method.
pbmc_orig <- FindVariableFeatures(pbmc_norm, selection.method = "vst", nfeatures = 2000)
pbmc_orig <- ScaleData(pbmc_orig)
pbmc_orig <- RunPCA(pbmc_orig, features = rownames(pbmc_dbf))
pbmc_orig <- RunUMAP(pbmc_orig, dims = 1:10)
pbmc_orig <- FindNeighbors(pbmc_orig, reduction = "pca", dims = 1:20)
pbmc_orig <- FindClusters(pbmc_orig)
dim_plot_orig <- DimPlot(pbmc_orig, reduction = "umap")

# Compare reduction map obtained with vst and DBFMCL filtering method.
dim_plot_orig + dim_plot_dbf
```


# Performing alternative cell ordering

It is easy to define alternative ordering for the columns/cells. For instance one may try the hierarchical clustering to try to put emphasis on some gene clusters.

```{r}
library(amap)
##  hclust on samples
hier_clustering <- hcluster(log2(t(dbf_seurat@data) +1), method="pearson", link="average", nbproc = 10)
dbf_hc <- dbf_seurat
dbf_hc@cell_order <- colnames(dbf_hc@data)[hier_clustering$order]

g_profiles_hc <- plot_clust(dbf_hc,
       average_only = TRUE,
       floor=-1, 
       type="tile",
       ceil=1)
g_profiles_hc
```






# R session

```{r}
sessionInfo()
```

        
        




